
%defines "parser.h"

%{
	#include <cmath>
	#include <cstdio>
	#include <iostream>
	#include <string>

	extern int yylex(); //will be generated by flex
	extern void yyerror(const char*); //code this

	using namespace std;
%}

%union {
	int intVal;
	double dblVal;
	char *strVal;
	bool boolVal;
}

/* Data types */
%token <intVal> INTEGER
%token <dblVal> DECIMAL
%token <strVal> STRING
%token <boolVal> BOOLEAN

/* Keywords */
%token KW_AND
%token KW_BOOLEAN
%token KW_BREAK
%token KW_CHOICE
%token KW_CLASS
%token KW_DOUBLE
%token KW_FOR
%token KW_FUNCTION
%token KW_IF
%token KW_IMPORT
%token KW_INPUT
%token KW_INT
%token KW_LOOP
%token KW_NEW
%token KW_NOT
%token KW_NULL
%token KW_OR
%token KW_OTHERWISE
%token KW_PROMPT
%token KW_RETURN
%token KW_STRING
%token KW_THIS
%token KW_TO
%token KW_UNLESS
%token KW_UNTIL
%token KW_WRITE
%token KW_WRITELINE

/* Operations */
%token ADD
%token SUB
%token MUL
%token DIV
%token MOD
%token EXP
%token EQUALS
%token ADD_EQ
%token SUB_EQ
%token MUL_EQ
%token DIV_EQ
%token MOD_EQ
%token EXP_EQ
%token INCREMENT
%token DECREMENT
%token IS_EQ_TO
%token LESSTHAN
%token GREATERTHAN
%token LTorEQ
%token GTorEQ
%token NOT_EQ

/* Identifier */
%token IDENTIFIER

/* Braces */
%token OPEN_PAREN
%token CLOSE_PAREN
%token OPEN_BRACE
%token CLOSE_BRACE
%token OPEN_BRACKET
%token CLOSE_BRACKET

/* Misc */
%token MEMBER
%token SEPARATOR
%token END_STMT
%token COMMENT

%left '+' '-'
%left '*' '/' '%'
%right '^'

%%

program:	file
			;

file:		statements
			;

statements:	/* empty */
			| statement
			| statements statement
			;

statement:	assignment
			| array
			| branch
			| break
			| class
			| function
			| import
			| loop
			| print
			| prompt
			| return_stmt
			;

assignment:	var ';'
			| var small_op ';'
			| var '=' expression ';'
			| var '=' KW_NULL ';'
			| var op_equal expression ';'
			| IDENTIFIER small_op ';'
			| IDENTIFIER '=' expression ';'
			| IDENTIFIER op_equal expression ';'
			| KW_THIS '.' IDENTIFIER '=' literal ';'
			| KW_THIS '.' IDENTIFIER '=' IDENTIFIER ';'
			;

var:		data_type IDENTIFIER
			;

data_type:	KW_INT
			| KW_DOUBLE
			| KW_STRING
			| KW_BOOLEAN
			;

expression:	add_sub
			| bool
			| obj_assign
			;

add_sub:	mul_div
			| add_sub '+' mul_div
			| add_sub '-' mul_div
			;

mul_div:	expnt
			| mul_div '*' expnt
			| mul_div '/' expnt
			| mul_div '%' expnt
			;

expnt:		paren
			| expnt '^' paren
			;

paren:		INTEGER
			| DECIMAL
			| '(' add_sub ')'
			| '(' conditions ')'
			;

bool:		BOOLEAN
			;

op_equal:	ADD_EQ		
			| SUB_EQ	
			| MUL_EQ	
			| DIV_EQ	
			| MOD_EQ	
			| EXP_EQ	
			;

small_op:	INCREMENT		
			| DECREMENT		
			;

obj_assign:	KW_NEW IDENTIFIER '(' ')'
			| KW_NEW IDENTIFIER '(' parameters ')'
			;
			
array:		var '=' '[' arr_content ']' ';'
			| IDENTIFIER '=' '[' arr_content ']' ';'
			;

arr_content:	/* empty */
				| literal
				| IDENTIFIER
				| literal ',' arr_content
				| IDENTIFIER ',' arr_content
				;

branch:		if_stmt
			| choice_stmt
			;

if_stmt:	req_if_stmt
			| req_if_stmt opt_if_stmt
			;

req_if_stmt:	KW_IF '(' conditions ')' '[' statements ']'
				;

opt_if_stmt:	KW_UNLESS '(' conditions ')' '[' statements ']'
				| KW_OTHERWISE '[' statements ']'
				;

conditions:	expression cond_op expression
			| conditions KW_AND conditions
			| conditions KW_OR conditions
			| expression cond_op expression KW_AND conditions
			| expression cond_op expression KW_OR conditions
			| KW_NOT conditions
			;

cond_op:	LESSTHAN
			| GREATERTHAN
			| IS_EQ_TO
			| LTorEQ
			| GTorEQ
			| NOT_EQ
			;

choice_stmt:	KW_CHOICE '(' IDENTIFIER ')' '[' choice_expr ']' ';'
				;

choice_expr:	literal '{' statements '}'
				| choice_expr literal '{' statements '}'
				| choice_expr KW_OTHERWISE '{' statements '}'
				;

break:		KW_BREAK ';'
			;

class:		KW_CLASS '(' ')' '[' statements ']'
			| KW_CLASS '(' parameters ')' '[' statements ']'
			;

function:	KW_FUNCTION '(' ')' '[' statements ']'
			| KW_FUNCTION '(' parameters ')' '[' statements ']'
			;

parameters:	var
			| var parameters
			| IDENTIFIER
			| IDENTIFIER parameters
			;

import:		KW_IMPORT package ';'
			;

package:	IDENTIFIER
			| IDENTIFIER '.' package
			;

loop:		loop_type
			;

loop_type:	default
			| forloop
			;

default:	KW_LOOP '[' statements ']' KW_UNTIL '(' conditions ')' ';'
			| KW_LOOP '[' statements ']' KW_UNTIL '(' conditions ')' KW_UNLESS '(' conditions ')' '[' statements ']' ';'
			;

forloop:	KW_FOR '(' IDENTIFIER KW_TO INTEGER ')' '[' statements ']'
			| KW_FOR '(' IDENTIFIER KW_TO DECIMAL ')' '[' statements ']'
			;

print:		KW_WRITE '(' write_expr ')' ';'
			| KW_WRITELINE '(' write_expr ')' ';'
			;

write_expr:	literal
			| IDENTIFIER
			| expression
			| literal ',' write_expr
			| IDENTIFIER ',' write_expr
			| expression ',' write_expr
			;

prompt:		KW_PROMPT '(' STRING ')' input ';'
			| KW_PROMPT '(' IDENTIFIER ')' input ';'
			;

input:		KW_INPUT '[' input_list ']' ';'
			;

input_list:	IDENTIFIER
			| IDENTIFIER ',' input_list
			;

return_stmt:	KW_RETURN literal ';'
				| KW_RETURN IDENTIFIER ';'
				| KW_RETURN '[' return_list ']' ';'
				;

return_list:	literal
				| IDENTIFIER
				| '[' statements ']'
				;

literal:	INTEGER
			| DECIMAL
			| STRING
			| BOOLEAN
			;