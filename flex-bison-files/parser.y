
%defines "parser.h"

%{
	#include <cmath>
	#include <cstdio>
	#include <iostream>
	#include <string>

	extern int yylex(); //will be generated by flex
	extern void yyerror(const char*); //code this

	using namespace std;
%}

%error-verbose

%union {
	int intVal;
	double dblVal;
	char *strVal;
	bool boolVal;
}

/* Data types */
%token <intVal> INTEGER
%token <dblVal> DECIMAL
%token <strVal> STRING
%token <boolVal> BOOLEAN

/* Keywords */
%token KW_AND
%token KW_BOOLEAN
%token KW_BREAK
%token KW_CHOICE
%token KW_CLASS
%token KW_DOUBLE
%token KW_FOR
%token KW_FUNCTION
%token KW_IF
%token KW_IMPORT
%token KW_INPUT
%token KW_INT
%token KW_LOOP
%token KW_NEW
%token KW_NOT
%token KW_NULL
%token KW_OR
%token KW_OTHERWISE
%token KW_PROMPT
%token KW_RETURN
%token KW_STRING
%token KW_THIS
%token KW_TO
%token KW_UNLESS
%token KW_UNTIL
%token KW_WRITE
%token KW_WRITELINE

/* Operations */
%token ADD_EQ
%token SUB_EQ
%token MUL_EQ
%token DIV_EQ
%token MOD_EQ
%token EXP_EQ
%token INCREMENT
%token DECREMENT
%token IS_EQ_TO
%token LTorEQ
%token GTorEQ
%token NOT_EQ

/* Identifier */
%token IDENTIFIER

%right '='
%left '+' '-'
%left '*' '/' '%'
%right '^'

%%

program
	: file
	;

file
	: /* empty */
	| statements
	;

statements
	: statement
	| statements statement
	;

statement
	: assignment
	| branch
	| break
	| class
	| function
	| import
	| loop
	| print
	| prompt
	| return
	;

assignment
	: var_assign
	| arr_assign
	| ident_assign
	| obj_assign
	;

var_assign
	: var ';'
	| var small_op ';'
	| var '=' expression ';'
	| var '=' IDENTIFIER '[' INTEGER ']' ';'
	| var op_equal expression ';'
	;

arr_assign
	: var '=' '[' ']' ';'
	| var '=' '[' arr_content ']' ';'
	| IDENTIFIER '=' '[' ']' ';'
	| IDENTIFIER '=' '[' arr_content ']' ';'
	;

arr_content
	: literal
	| IDENTIFIER
	| arr_content ',' literal
	| arr_content ',' IDENTIFIER
	;

ident_assign
	: IDENTIFIER small_op ';'
	| IDENTIFIER '=' expression ';'
	| IDENTIFIER '=' IDENTIFIER '[' INTEGER ']' ';'
	| IDENTIFIER op_equal expression ';'
	| IDENTIFIER op_equal IDENTIFIER '[' INTEGER ']' ';'
	| KW_THIS '.' IDENTIFIER '=' IDENTIFIER ';'
	;

obj_assign
	: var '=' KW_NEW IDENTIFIER '(' ')' ';'
	| var '=' KW_NEW IDENTIFIER '(' parameters ')' ';'
	| var '=' KW_NULL ';'
	;

var
	: data_type IDENTIFIER
	| data_type '[' ']' IDENTIFIER
	| data_type '[' INTEGER ']' IDENTIFIER
	;

data_type
	: KW_INT
	| KW_DOUBLE
	| KW_STRING
	| KW_BOOLEAN
	| IDENTIFIER	/* should probably create a separate object identifier type. but this will work for now */
	;

expression
	: literal
	| add_sub
	;

add_sub
	: mul_div
	| add_sub '+' mul_div
	| add_sub '-' mul_div
	;

mul_div
	: expnt
	| mul_div '*' expnt
	| mul_div '/' expnt
	| mul_div '%' expnt
	;

expnt
	: paren
	| expnt '^' paren
	;

paren
	: '(' add_sub ')'
	| '(' conditions ')'
	;

op_equal
	: ADD_EQ		
	| SUB_EQ	
	| MUL_EQ	
	| DIV_EQ	
	| MOD_EQ	
	| EXP_EQ	
	;

small_op
	: INCREMENT		
	| DECREMENT		
	;

branch
	: if_stmt
	| choice_stmt
	;

if_stmt
	: KW_IF '(' conditions ')' '[' statements ']'
	| KW_IF '(' conditions ')' '[' statements ']' unless_stmt
	;

unless_stmt
	: KW_UNLESS '(' conditions ')' '[' statements ']'
	| unless_stmt KW_OTHERWISE '[' statements ']'
	;

conditions
	: condition
	| conditions condition
	;

condition
	: expression cond_op expression
	| expression KW_AND expression
	| expression KW_OR expression
	| KW_NOT condition
	;

cond_op
	: '<'
	| '>'
	| IS_EQ_TO
	| LTorEQ
	| GTorEQ
	| NOT_EQ
	;

choice_stmt
	: KW_CHOICE '(' IDENTIFIER ')' '[' choice_expr ']' ';'
	;

choice_expr
	: literal '{' statements '}'
	| choice_expr literal '{' statements '}'
	| choice_expr KW_OTHERWISE '{' statements '}'
	;

break
	: KW_BREAK ';'
	;

class
	: KW_CLASS IDENTIFIER '(' ')' '[' statements ']'
	| KW_CLASS IDENTIFIER '(' parameters ')' '[' statements ']'
	;

function
	: KW_FUNCTION IDENTIFIER '(' ')' '[' statements ']'
	| KW_FUNCTION IDENTIFIER '(' parameters ')' '[' statements ']'
	;

parameters
	: var
	| IDENTIFIER
	| parameters ',' var
	| parameters ',' IDENTIFIER
	;

import
	: KW_IMPORT package ';'
	;

package
	: IDENTIFIER
	| package '.' IDENTIFIER
	;

loop
	: default
	| forloop
	;

default
	: KW_LOOP '[' statements ']' KW_UNTIL '(' conditions ')' ';'
	| KW_LOOP '[' statements ']' KW_UNTIL '(' conditions ')' KW_UNLESS '(' conditions ')' '[' statements ']' ';'
	;

forloop
	: KW_FOR '(' IDENTIFIER KW_TO INTEGER ')' '[' statements ']'
	| KW_FOR '(' var KW_TO INTEGER ')' '[' statements ']'
	;

print
	: KW_WRITE '(' write_expr ')' ';'
	| KW_WRITELINE '(' write_expr ')' ';'
	;

write_expr
	: expression
	| write_expr ',' expression
	;

prompt
	: KW_PROMPT '(' STRING ')' input ';'
	| KW_PROMPT '(' IDENTIFIER ')' input ';'
	;

input
	: KW_INPUT '[' input_list ']'
	;

input_list
	: IDENTIFIER
	| IDENTIFIER ',' input_list
	;

return
	: KW_RETURN literal ';'
	| KW_RETURN IDENTIFIER ';'
	| KW_RETURN KW_NULL ';'
	| KW_RETURN '[' return_list ']' ';'
	;

return_list
	: literal
	| IDENTIFIER
	| KW_NULL
	| statements
	;

literal
	: number
	| non_number
	;
	
number	
	: INTEGER
	| DECIMAL
	; 
	
non_number	
	: STRING
	| BOOLEAN
	;
